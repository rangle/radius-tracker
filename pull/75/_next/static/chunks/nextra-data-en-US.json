{"/analysis":{"title":"Analyzing the output","data":{"":"Tracker generates an SQLite database with entries for each detected component usage and,\nby default, writes it to usages.sqlite.gz in the current directory. You have a few ways to visualize this data.","local-report#Local report":"The easiest way to visualize the Tracker data is by generating a report using\nnpx radius-tracker report\nTo view, host the report files on an http server,\nfor example, using npx serve ./radius-tracker-report on a local machine.This report is entirely self-contained without external references.\nSee the CI integration guide for archiving.","observablehq#ObservableHQ":"We are using the sample ObservableHQ report\nas a template for the local reports. To make changes in that report:\nFork the sample report\nReplace the attached database with the Tracker database you generated","custom-templates-for-local-reports#Custom templates for local reports":"You can use a fork of an ObservableHQ report as a template for a local report generator.\nSee above for forking the default report. Get an export link from Export → Download code of a report you want to use.\nSee ObservableHQ export documentation for details.Paste the link into the following command to generate a report template:\nnpx radius-tracker report-generate-template https://your-export-url\nYou can then generate the report using your template:\nnpx radius-tracker report --template=./path/to/template\nWhile this is the same mechanism we use to generate the bundled report template, this is an experimental feature.\nReport templates are supposed to be self-contained, and the generator is tightly coupled with the default report\nto support that. The API of the report generator is unstable, and there's no guarantee that it will work for you.","alternative-reporting-tools#Alternative reporting tools":"If you want to run an analysis not covered by the default Tracker report, you can connect the usages database\nto various data analysis tools.Both Tableau and Power BI support SQLite as a data source using an SQLite ODBC Driver.\nTake a look at the documentation for Tableau\nand for Power BI.Keep track of the schemaVersion\nin the meta table — your reports might need to be updated if the schema changes between Tracker version upgrades."}},"/configuration_file":{"title":"Tracker configuration","data":{"":"We designed Tracker to collect historical usage stats from the entire ecosystem of UI projects within the organization.\nIt requires describing the project ecosystem and setting up Tracker to run on schedule\nto update the data and generate a new report.You can collect the data by running\nnpx radius-tracker timelines ./path/to/config.js","config-file-structure#Config file structure":"Tracker config is a .js file with an array of entries for each repo you want to process\nexport default [\n{\n// Git clone URL.\n// This URL can use any protocol git supports, including SSH and local files.\n// https://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols#_the_protocols\nrepoUrl: \"https://githost.com/company/product\",\n\n// [optional] Repository name to use in reports. Defaults to `repoUrl`.\ndisplayName: \"My repo\",\n\n// Regexp testing if an import path comes from the design system.\n// See the document below for multi-target configuration,\n// and handling file targets.\nisTargetModuleOrPath: /^@company\\/design-system/,\n\n// How far into history should Tracker look — a date in the past.\n// Conflicts with `maxWeeks`\nsince: new Date(\"2021-03-12\"),\n\n// Alternative way to specify how far into history Tracker would look.\n// Conflicts with `since` — prefer using `since` instead to set an explicit date.\nmaxWeeks: 52,\n\n// [optional] Subproject path denotes where in the monorepo the project code is located\n//            relative to the repository root.\n//            Defaults to \"/\"\nsubprojectPath: \"/\",\n\n// [optional] Regexp specifying which file paths to exclude.\n//            See the document below for the default value & details.\nisIgnoredFile: /\\/node_modules\\//,\n\n// [optional] Function narrowing down if the import matched by `isTargetModuleOrPath`\n//            should be considered for analysis. See the document below for the default value & details.\nisTargetImport: imp => imp.type !== \"cjs-import\", // This example excludes `require` calls\n\n// [optional] Function checking if Tracker should include a particular usage found in code\n//            in the analysis. See the document below for details.\n//            Defaults to `() => true`\nisValidUsage: () => true,\n\n// [optional] String path specifying where tsconfig.json is located relative to `subprojectPath`\n//            TSConfig helps Tracker resolve which files to include and how to navigate\n//            the dependencies. Make sure this points to the correct file if it exists.\n//            Defaults to \"tsconfig.json\"\n//            Conflicts with `jsconfigPath`\ntsconfigPath: \"tsconfig.json\",\n\n// [optional] String path specifying where jsconfig.json is located relative to `subprojectPath`\n//            Some projects use a JSConfig to specify data about the project: https://code.visualstudio.com/docs/languages/jsconfig\n//            Tracker can use it to adjust its behavior, similar to `tsconfigPath` above.\n//            Defaults to \"jsconfig.json\"\n//            Conflicts with `tsconfigPath`\njsconfigPath: \"jsconfig.json\"\n},\n/* ...repeat for other projects */\n];\nFor reference, you can find the configuration used to generate the Tracker sample report\nunder /src/lib/cli/test/grafana_samples.tsThe full definition is WorkerConfig\nextending StatsConfig.","multi-target-configuration#Multi-target configuration":"Besides your design system, UI projects in your organization ecosystem might use other component sources.\nTo specify multiple sources, provide a set of regexps in isTargetModuleOrPath:\nconst targets = {\nds: /^@company\\/design-system/,\nmaterial: /^(@mui|@material-ui)/,\nant: /^(antd|@ant-design)/,\n};\n\nexport default [{\nisTargetModuleOrPath: targets,\n// ...rest of the configuration\n}]\nTracker collects usages separately for each target in the set. That way, each usage\nis attributable to the particular source during the analysis.","handling-file-targets#Handling file targets":"Some projects store the component library within the repo.Tracker supports file paths as targets, e.g., isTargetModuleOrPath: /src\\/components/\nIn this case, Tracker will ignore any usage found within src/components under the assumption\nthat it forms a part of the component library implementation.","ignored-files#Ignored files":"isIgnoredFile regexp filters out files that Tracker should not be analyze for component usage.\nFile paths are given relative to the subprojectPath within the project.By default, Tracker ignores\nfiles in the node_modules directory\n__mocks__ folders\n.spec.<ext> and .test.<ext> along with /test/ and /spec/ directories to filter out common test files\n.story.<ext> and .stories.<ext> along with /story/ and /stories/ directories to filter out common storybook locations\n.d.ts files with typescript definitions.\n\nIgnoring the files improves Tracker performance by avoiding unnecessary work.\nIt also enhances the output quality by removing non-production usages of components in tests and stories.See the implementation for the default regexp.If you specify isIgnoredFile regexp, we advise you to filter out node_modules —\nparsing the dependencies takes forever if present.","ignored-imports#Ignored imports":"Similar to ignored files, isTargetImport specifies which particular imports Tracker should ignore.isTargetImport is a function receiving an import model\nas input and determining if this import should be included. The import model references the particular AST node\nwhere the import happens and contains pre-processed information about that import.Filtering imports improves Tracker performance, though insignificantly compared to ignored files.\nMost importantly, filtering imports prevents non-components from polluting the output.Even though the import model contains a moduleSpecifier, consider updating the target regexp if you need to filter on module names or paths.The default implementation\nfilters out lower-case named imports — typically not React Components — and all-caps named imports — usually constant values.This function gets sent to the worker processes, so its implementation needs to be serializable via .toString() and de-serializable via eval().\nIt can not use scoped variables, as those don't get serialized with fn.toString()","valid-usages-filter#Valid usages filter":"As a last resort, you can use isValidUsage function to filter out incorrect data from the output.\nThis function receives a usage model\nreferencing the particular AST node that Tracker considers a component usage.The default implementation\nis () => true — accepting all found usages as valid.This function gets sent to the worker processes, so its implementation needs to be serializable via .toString() and de-serializable via eval().\nIt can not use scoped variables, as those don't get serialized with fn.toString()"}},"/ci_integration":{"title":"CI Integration","data":{"":"We designed Tracker to run on schedule in CI so that the team can routinely review the design system adoption progress.\nFor example, in Github Actions you can use the schedule trigger.Tracker takes a snapshot of the latest state of the codebase and weekly snapshots of each project's history.\nWeekly snapshots are aligned with the latest commit as of midnight on Saturday every week.We recommend scheduling Tracker to run a day or two before the rituals where the team reviews the progress.","artifacts#Artifacts":"Tracker outputs are self-contained and can be archived.\nWe suggest generating and storing a report for reference using Upload Artifact\nGithub Action or a similar step in your CI.","cache#Cache":"Running static code analysis of an entire organizational ecosystem history takes considerable time.Tracker writes intermediary results per project per commit into a specified --cacheDir.\nBy default, the cache is written to radius-tracker-cache/cacheSaving and restoring the cache between tracker runs will save significant CPU time\nby avoiding the re-processing of historical commits.Cache content is versioned with a constant from src/lib/cli/util/cacheVersion.ts\n— you can use a hash of that file as the cache key. For example,\nin Github Actions you can use hashFiles('**/cacheVersion.ts')","resource-consumption#Resource consumption":"Static code analysis is resource-heavy. Tracker can take hours to run, especially without cache,\nwhen processing a project for the first time. Please provide sufficient CPU and Memory,\nand ensure that your CI runner doesn't kill the Tracker task too early.CPU time is a primary limiting factor for Tracker. It runs multiple child processes,\neach analyzing a single commit, to better utilize available CPUs.Tracker allocates a minimum of 2GB of Memory per child process, so the number of child processes might be limited\non machines with low total memory.On top of potentially significant amounts of cache, Tracker fetches all the projects specified in the config file\nand creates a copy per thread. Make sure there is enough disk space for Tracker to run.","restricting-network-access#Restricting network access":"Tracker requires no network access to run beyond fetching the git repos.\nConsider fetching the project repos to the local filesystem and clamping down the firewall\nbefore running or even installing Tracker to eliminate the potential for leaking the analyzed codebase.Alternatively, you can limit network access to only allow outgoing connections to the git hosting.","automated-project-discovery#Automated project discovery":"Depending on the git hosting platform, you might be able to automatically discover\nnew UI projects in the organization ecosystem.For example, you can use Github Search API\nto search for package.json files containing a reference to your design system or frontend frameworks:\norg:<your_organization>+in:file+filename:package.json+language:json+<your_design_system_package>\nYou can then programmatically generate the config file using the list of discovered projects."}},"/":{"title":"Radius Tracker","data":{"":"Track every use\nof every component\nin every codebase\nin your company.\nRadius Tracker generates reports measuring design system adoption, calculated bottom-up from individual component usage stats automatically collected from your organization repositories."}},"/quick_start":{"title":"Quick start","data":{"":"Run this in a project directory you want to analyze:\nnpx radius-tracker in-place --targetRe \"^@corporation/your-designsystem\"\nThis way, Tracker will produce a snapshot of component usages from a single target for the files in the current directory.--targetRe is a regexp matched against module specifiers in import statements and require calls:\nimport { Component } from \"module-specifier\";\nrequire(\"module-specifier\");\nCheck out npx radius-tracker in-place --help for more configuration parameters.","next-steps#Next steps":"You can analyze Tracker output as is. However, the in-place run described above\nonly collects data for the current state of a single project. And running Tracker manually like this\nis not sustainable for regularly collecting the data.Follow the configuration guide to set up a repeatable process of generating Tracker reports."}},"/supported_technologies":{"title":"Supported technologies","data":{"":"Tracker currently only supports React projects written in JavaScript or TypeScript.For the purpose of homebrew detection, Tracker only supports lowercase JSX elements like <div/>,\nas opposed to CSS-in-JS wrappers typically used as styled.div. See the report intro\nfor more information about homebrew components.","other-frameworks#Other frameworks":"The frameworks vary greatly in ways they define a component, usage of a component, and dependencies between components.\nIt makes it hard to support other popular frameworks out of the box.Let us know\nif you want to see support for a particular technology."}}}